/**
 *	@file		Direct3D12Device.cpp
 *	@brief		Direct3D12デバイスに関する処理を行うプログラムソース
 *	@author		kkllPreciel
 *	@date		2017/02/07
 *	@version	1.0
 */

#if _DEBUG
#include <sstream>
#endif
#include <winerror.h>
#include "Direct3D12Device.h"

namespace Sein
{
	namespace Direct3D12
	{
		/** 
		 *	@brief	コンストラクタ
		 */
		Device::Device() :
			device(nullptr), swapChain(nullptr), commandQueue(nullptr), commandAllocator(nullptr),
			commandList(nullptr), descriptorHeap(nullptr), descriptorSize(0), bufferIndex(0),
			fence(nullptr), fenceIndex(0), fenceEvent(nullptr)
		{
			for (auto i = 0; i < FrameCount; ++i)
			{
				renderTargetList[i] = nullptr;
			}
		}

		/**
		 *	@brief	デストラクタ
		 */
		Device::~Device()
		{
			Release();
		}

		/**
		 *	@brief	デバイスを生成する
		 *	@param	handle:ウィンドウハンドル
		 *	@param	width:横幅
		 *	@param	height:縦幅
		 */
		void Device::Create(HWND handle, unsigned int width, unsigned int height)
		{
#if _DEBUG
			// デバッグレイヤーを有効に設定する
			Microsoft::WRL::ComPtr<ID3D12Debug> debugInterface;
			if (FAILED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugInterface))))
			{
				throw "デバッグレイヤーの生成に失敗しました。";	
			}
			debugInterface->EnableDebugLayer();
#endif
			// ファクトリの生成
			// アダプターの列挙に使用
			Microsoft::WRL::ComPtr<IDXGIFactory4> factory;

			if (FAILED(CreateDXGIFactory1(IID_PPV_ARGS(&factory))))
			{
				throw "DXGIファクトリの生成に失敗しました。";
			}

			// Direct3D12のデバイスを作成する
			{
#if 1
				// デバイスを生成
				// アダプターを列挙し作成すると
				// 環境によってメモリリークが発生したため
				// デフォルトのアダプターを使用し作成する
				if (FAILED(D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&device))))
				{
					throw "デバイスの生成に失敗しました。";
				}
#else
				Microsoft::WRL::ComPtr<IDXGIAdapter1> pAdapter;

				// アダプター(ビデオカード)を列挙する
				for (auto i = 0; DXGI_ERROR_NOT_FOUND != factory->EnumAdapters1(i, &pAdapter); ++i)
				{
					DXGI_ADAPTER_DESC1 desc;
					pAdapter->GetDesc1(&desc);

					// TODO:調査
					if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
					{
						continue;
					}

					// デバイスを作成
					if (FAILED(D3D12CreateDevice(pAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&device))))
					{
						continue;
					}

#if _DEBUG
					std::wostringstream ostr;
					pAdapter->GetDesc1(&desc);
					ostr << "D3D12-capable hardware found:" << desc.Description << "(" << (desc.DedicatedVideoMemory >> 20) << "MB)\n";
					OutputDebugString(ostr.str().c_str());
#endif
				}

				// WARPで生成する
				if (nullptr == device)
				{
#if _DEBUG
					OutputDebugString(L"WARP software adapter requested.  Initializing...\n");
#endif
					if (FAILED(factory->EnumWarpAdapter(IID_PPV_ARGS(&pAdapter))))
					{
						throw "WARPアダプターが存在しません。";
					}

					if (FAILED(D3D12CreateDevice(pAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&device))))
					{
						throw "デバイスの生成に失敗しました。";
					}
				}
#endif
			}

			// コマンドキューの作成
			// コマンドキューはGPUへ描画命令が出されたコマンドリストを
			// 順次実行する
			// つまり特定のアダプター(GPU)に関連付けられている
			{
				D3D12_COMMAND_QUEUE_DESC queueDesc = {};
				queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;	// タイムアウト処理を有効にする
				queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;	// レンダリング関連のコマンドリスト

				if (FAILED(device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&commandQueue))))
				{
					throw "コマンドキューの生成に失敗しました。";
				}
			}

			// スワップチェインの作成
			// コマンドキューを指定して作成する = アダプターを指定して作成する
			{
				DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {};
				swapChainDesc.Width = width;									// ウィンドウ横幅
				swapChainDesc.Height = height;									// ウィンドウ縦幅
				swapChainDesc.BufferCount = FrameCount;							// バッファの数は2個(フロントバッファも含むらしいが、公式サンプル等を見るとバックバッファの数な気がする)
				swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;				// 恐らくバッファのフォーマット(4 成分、32 ビット符号なし整数)
				swapChainDesc.Scaling = DXGI_SCALING_NONE;						// 画面サイズとバッファサイズが等しくない時の拡縮動作(拡大縮小は行わない)
				swapChainDesc.SampleDesc.Quality = 0;							// マルチサンプリングの品質レベル
				swapChainDesc.SampleDesc.Count = 1;								// ピクセル単位のマルチサンプリング数
				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;	// バックバッファの使用目的及びCPUアクセスオプション(レンダーターゲットとして使用)
				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;	// スワップチェインの動作オプション(モード切替可能に設定)
				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;		// フロントバッファとバックバッファのスワップ挙動指定(バックバッファがディスプレイに表示されたら破棄する)

				Microsoft::WRL::ComPtr<IDXGISwapChain1> pSwapChain;
				if (FAILED(factory->CreateSwapChainForHwnd(
					commandQueue,	// コマンドキュー
					handle,			// ウィンドウハンドル
					&swapChainDesc,	// スワップチェインの設定情報
					nullptr,		// フルスクリーンスワップチェインの設定(ウィンドウモードで作成するのでnullptr)
					nullptr,		// TODO:調査
					&pSwapChain)))
				{
					throw "スワップチェインの生成に失敗しました。";
				}
				
				if (FAILED(pSwapChain.Get()->QueryInterface(IID_PPV_ARGS(&swapChain))))
				{
					throw "IDXGISwapChain3の生成に失敗しました。";
				}

				// バックバッファの番号を取得する
				bufferIndex = swapChain->GetCurrentBackBufferIndex();
			}

			// コマンドアロケーターの生成
			// コマンドに使用するバッファ領域を確保する物
			{
				if (FAILED(device->CreateCommandAllocator(
					D3D12_COMMAND_LIST_TYPE_DIRECT,	// コマンドアロケーターの種別(レンダリング関連のコマンドリストを設定)
					IID_PPV_ARGS(&commandAllocator))))
				{
					throw "コマンドアロケーターの生成に失敗しました。";
				}
			}

			// コマンドリストの生成
			// コマンドキューに渡すコマンドのリスト
			{
				if (FAILED(device->CreateCommandList(
					0,									// マルチアダプター(マルチGPU)の場合に使用するアダプター(GPU)の識別子(単一なので0)
					D3D12_COMMAND_LIST_TYPE_DIRECT,		// コマンドリストの種別(レンダリング関連のコマンドリスト)
					commandAllocator,					// このコマンドリストで使用するコマンドアロケーター
					nullptr,							// コマンドリストの初期パイプライン状態(ダミーの初期パイプラインを指定)
					IID_PPV_ARGS(&commandList))))
				{
					throw "コマンドリストの生成に失敗しました。";
				}
			}

			// Alt + Enterでフルスクリーン化の機能を無効に設定
			factory->MakeWindowAssociation(handle, DXGI_MWA_NO_ALT_ENTER);

			// ディスクリプターヒープの作成
			// ディスクリプターはバッファの情報データ(テクスチャバッファ、頂点バッファ等)
			{
				D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
				rtvHeapDesc.NumDescriptors = FrameCount;				// ディスクリプターヒープ内のディスクリプター数(フロントバッファ、バックバッファ)
				rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;		// 種別はレンダーターゲットビュー
				rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;	// シェーダーから参照しない

				if (FAILED(device->CreateDescriptorHeap(
					&rtvHeapDesc,	// ディスクリプターヒープの設定情報
					IID_PPV_ARGS(&descriptorHeap
					))))
				{
					throw "ディスクリプターヒープの生成に失敗しました。";
				}

				// レンダーターゲット分のディスクリプターのサイズを取得する
				descriptorSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
			}

			// ディスクリプターの登録
			{
				D3D12_CPU_DESCRIPTOR_HANDLE renderTargetViewHandle(descriptorHeap->GetCPUDescriptorHandleForHeapStart());

				// フレームバッファ数文登録する
				for (auto i = 0; i < FrameCount; ++i)
				{
					if (FAILED(swapChain->GetBuffer(i, IID_PPV_ARGS(&renderTargetList[i]))))
					{
						throw "バックバッファの取得に失敗しました。";
					}

					// レンダーターゲットビューを作成する
					device->CreateRenderTargetView(
						renderTargetList[i],	// レンダー ターゲットを表すID3D12Resourceへのポインタ
						nullptr,				// D3D12_RENDER_TARGET_VIEW_DESCへのポインタ
						renderTargetViewHandle
					);

					renderTargetViewHandle.ptr += descriptorSize;
				}
			}

			// フェンスの生成
			// Directx12ではGPUの描画の終了待ちを自動で行わない(同期が取れず画面がおかしくなる)
			// そのため同期を取るためのオブジェクト(フェンス)を作成する
			{
				if (FAILED(device->CreateFence(
					fenceIndex,				// フェンスの初期値
					D3D12_FENCE_FLAG_NONE,	// オプションの指定(今回は指定なし)
					IID_PPV_ARGS(&fence))))
				{
					throw "フェンスの生成に失敗しました。";
				}

				++fenceIndex;

				// 同期待ち用のイベントを生成
				if (nullptr == (fenceEvent = CreateEvent(nullptr, false, false, nullptr)))
				{
					throw "イベントの生成に失敗しました。";
					// throw HRESULT_FROM_WIN32(GetLastError());
				}

				// 描画処理を行っている可能性があるので描画終了待ちを行う
				WaitForGpu();
			}
		}

		/**
		 *	@brief	デバイスを開放する
		 */
		void Device::Release()
		{
			// GPUの描画終了待ちを行う
			WaitForGpu();

			CloseHandle(fenceEvent);

			fence->Release();

			for (auto i = 0; i < FrameCount; ++i)
			{
				renderTargetList[i]->Release();
			}

			descriptorHeap->Release();
			commandList->Release();
			commandAllocator->Release();
			commandQueue->Release();
			swapChain->Release();
			device->Release();
		}

		/**
		 *	@brief	画面を更新する
		 */
		void Device::Present()
		{

		}

		// 後々別クラスへ移動する
#pragma region Fence

		/**
		 *	@brief	描画終了待ちを行う
		 */
		void Device::WaitForGpu()
		{
			// 実行されているコマンドリストが完了したら
			// フェンスに指定の値を設定するようにする
			if (FAILED(commandQueue->Signal(fence, fenceIndex)))
			{
				throw "コマンドキューのシグナル設定に失敗しました。";
			}

			// 既に処理が終わっている場合は実行しない
			if (fence->GetCompletedValue() < fenceIndex)
			{
				// フェンスの値が設定した値になったら
				// 指定したイベントを発行させる
				if (FAILED(fence->SetEventOnCompletion(fenceIndex, fenceEvent)))
				{
					throw "フェンスのイベント発行設定に失敗しました。";
				}

				// シグナル状態(イベント発行)になるまで待機する
				WaitForSingleObjectEx(fenceEvent, INFINITE, false);
			}

			// フェンスの値を更新する
			++fenceIndex;
		}

#pragma endregion
	};
};